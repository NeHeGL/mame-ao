<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width">

	<link rel="stylesheet" type="text/css" href="/styles.css" />

	<style>
		/* Column sorting styles */
		th .sort-indicator {
			font-size: 0.8em;
			color: #999;
			margin-left: 4px;
		}
		
		th[data-sort-direction="asc"] .sort-indicator,
		th[data-sort-direction="desc"] .sort-indicator {
			color: #000;
			font-weight: bold;
		}
		
		th:hover .sort-indicator {
			color: #666;
		}
		
		/* Grid layout for machines and software */
		.game-grid {
			display: grid;
			grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
			gap: 15px;
			padding: 10px;
		}
		
		.game-card {
			border: 1px solid #ccc;
			border-radius: 8px;
			overflow: hidden;
			background: #fff;
			transition: transform 0.2s, box-shadow 0.2s;
			cursor: pointer;
		}
		
		.game-card:hover {
			transform: translateY(-5px);
			box-shadow: 0 5px 15px rgba(0,0,0,0.3);
		}
		
		.game-card-image {
			width: 100%;
			height: 180px;
			background: #f0f0f0;
			display: flex;
			align-items: center;
			justify-content: center;
			overflow: hidden;
		}
		
		.game-card-image img {
			width: 100%;
			height: 100%;
			object-fit: cover;
			image-rendering: -webkit-optimize-contrast;
			image-rendering: crisp-edges;
			image-rendering: pixelated;
			-ms-interpolation-mode: nearest-neighbor;
			backface-visibility: hidden;
			-webkit-backface-visibility: hidden;
			transform: translateZ(0);
			-webkit-transform: translateZ(0);
		}
		
		.game-card-info {
			padding: 8px;
			font-size: 9px;
			line-height: 1.3;
			background: #fafafa;
		}
		
		.game-card-title {
			font-weight: bold;
			font-size: 11px;
			margin-bottom: 4px;
			overflow: hidden;
			text-overflow: ellipsis;
			white-space: nowrap;
		}
		
		.game-card-row {
			display: flex;
			justify-content: space-between;
			margin-bottom: 2px;
		}
		
		.game-card-label {
			color: #666;
			font-weight: bold;
		}
		
		.game-card-value {
			color: #000;
			text-align: right;
			overflow: hidden;
			text-overflow: ellipsis;
			white-space: nowrap;
			max-width: 60%;
		}
		
		.game-card-fav {
			position: absolute;
			top: 5px;
			right: 5px;
			z-index: 10;
		}
		
		.game-card-status-good { background-color: #90EE90; }
		.game-card-status-imperfect { background-color: #FFD700; }
		.game-card-status-preliminary { background-color: #FFA500; }
	</style>

	<script type="text/javascript">

		const _rootMenu =
			[{
				text: 'MAME-AO',
				title: 'MAME-AO',
				href: '/',
				menu: [
					{
						text: 'Machines',
						title: 'Start Machines',
						href: '/machines',
					},
					{
						text: 'Genres',
						title: 'Machines by Genre',
						href: '/genres',
					},
					{
						text: 'Saved State',
						title: 'View saved state & Previous MAME versions',
						href: '/saved',
					},
					{
						text: 'Reporting',
						title: 'Information Reporting',
						href: '/reports',
						menu: [
							{
								text: 'Run Reports',
								title: 'Run Reports',
								href: '/reports/run',
							},
							{
								text: 'View Reports',
								title: 'View Veports',
								href: '/reports/view',
							},
							{
								text: 'SQL Query',
								title: 'SQL Query',
								href: '/reports/sql',
							},
						],
					},
					{
						text: 'Import',
						title: 'Import into MAME-AO',
						href: '/import',
					},
					{
						text: 'Export',
						title: 'Export from MAME-AO',
						href: '/export',
					},
					{
						text: 'Tools',
						title: 'Tools',
						href: '/tools',
					},
					{
						text: 'Settings',
						title: 'Settings - User Preferences',
						href: '/settings',
					},
					{
						text: 'BitTorrent',
						title: 'BitTorrent Client Information',
						href: '/bittorrent',
					},
					{
						text: 'About',
						title: 'About & System Information',
						href: '/about',
					},
				],
			}];

		//
		// Main
		//

		let _baseUrl;
		let _parameters;
		let _path;
		let _pathParts;
		let _info;
		let _currentMenu;
		let _inTick = false;

		const main = async () => {

			try {

				getRequestInfo();

				await mainWork();

				await tick();
				setInterval(tick, 2000);

			} catch (error) {

				const div = document.getElementById('error');

				const html = `<h2>MAME-AO UI Error : ${error.name}</h2>` +
					'<p>If you want to submit an error report please copy and paste the error text from here. Maybe include a screen shot.</p>' +
					'<p>Copy (Ctrl+C) -> notepad -> paste (Ctrl+V).</p>' +
					'<p>Report issues here <a href="https://github.com/sam-ludlow/mame-ao/issues" target="_blank" >https://github.com/sam-ludlow/mame-ao/issues</a></p>' +
					'<hr />' +
					`<p>${error.stack}</p>` +
					'<hr />';

				div.innerHTML = html;
				div.style = 'background-color: pink;';

				throw error;
			}
		}

		//
		// Status tick
		//

		const tick = async () => {

			if (_inTick === true)
				return;

			_inTick = true;

			let status;

			try {
				status = await fetchJson('/api/status');
			}
			catch (e) {
				alert(`Problem connecting to MAME-AO server.\n\nHave you closed the console?\n\nStart MAME-AO again or close this window.\n\nError: ${e.message}`);
			}

			try {

				document.body.className = status.busy === true ? 'busy' : '';

				const topRow = document.getElementById('nav').children[0].rows[0];

				let statusElement = [...topRow.children].find(element => element.id === 'status');

				if (status.busy === false && statusElement)
					statusElement.remove();

				if (status.busy == true) {
					if (!statusElement) {
						statusElement = document.createElement('td');
						statusElement.id = 'status';
						topRow.appendChild(statusElement);
					}

					statusElement.style.textAlign = 'center';

					let message = `Running Command: "${status.command}"`;

					if (status.bytesTotal > 0) {
						const percent = ((100 / status.bytesTotal) * status.bytesCurrent).toFixed(2);
						message += `, Progress: ${status.bytesCurrent} of ${status.bytesTotal} (${percent}%)`;

						statusElement.style.color = percent < 30 ? '#ffffff' : '#000000';

						let red = (percent >= 50) ? Math.round((50 - (percent - 50)) * 5.1) : 255;
						let green = (percent < 50) ? Math.round(percent * 5.1) : 255;

						statusElement.style.backgroundColor = `rgb(${red}, ${green}, 0)`;
					} else {
						statusElement.style.backgroundColor = '#ffff00';
					}

					statusElement.innerHTML = message;
				}
			}
			finally {
				_inTick = false;
			}
		}

		const mainWork = async () => {

			//
			// Info
			//

			_info = await fetchJson('/api/info');


			//
			// load machines menu
			//
			if (_pathParts.includes('/machines')) {
				const dataProfiles = await fetchJson('/api/profiles');

				_rootMenu[0].menu[0].menu = dataProfiles.results.map((profile) => {
					return {
						text: profile.text,
						title: profile.description,
						href: `/machines/${profile.key}`,
					};
				});
			}

			//
			// load software menu
			//
			let machineData;

			if (_pathParts.includes('/machines') && _pathParts.length >= 4) {

				let current;
				_rootMenu[0].menu[0].menu.forEach((item) => {
					if (_pathParts[2] === item.href)
						current = item;
				});

				if (current === undefined)
					throw new Error('current machine menu not found');

				let parts = _pathParts[2].split('/');
				const profileName = parts[parts.length - 1];

				parts = _pathParts[3].split('/');
				const machineName = parts[parts.length - 1];

				machineData = await fetchJson(`/api/machine?name=${machineName}`);

				current.menu = [{
					text: `${machineData.name} &bull; ${machineData.description}`,
					title: machineData.description,
					href: `/machines/${profileName}/${machineName}`,
				}];

				current.menu[0].menu = machineData.softwarelists.map((list) => {
					return {
						text: list.description,
						title: list.description,
						href: `/machines/${profileName}/${machineName}/${list.name}`,
					};
				});

				current.menu[0].menu.push({
					text: 'Favorites',
					title: 'Favorites',
					href: `/machines/${profileName}/${machineName}/@fav`,
				});

			}

			//
			// genre menu
			//

			if (_info.genre_version === '') {
				_rootMenu[0].menu.splice(1, 1);
			} else {
				if (_pathParts.includes('/genres') && _pathParts.length >= 3) {

					let parts = _pathParts[2].split('/');
					const group_name_enc = parts[parts.length - 1];
					const group_name = decodeURIComponent(group_name_enc);

					_rootMenu[0].menu[1].menu = [{
						text: group_name,
						title: group_name,
						href: `/genres/${group_name_enc}`,
					}];

					if (_pathParts.length >= 4) {

						parts = _pathParts[3].split('/');
						const genre_name_enc = parts[parts.length - 1];
						const genre_name = decodeURIComponent(genre_name_enc);

						_rootMenu[0].menu[1].menu[0].menu = [{
							text: genre_name,
							title: genre_name,
							href: `/genres/${group_name_enc}/${genre_name_enc}`,
						}];
					}
				}
			}

			displayMenu();

			//
			// Route
			//

			if (_pathParts.includes('/machines') && _pathParts.length === 3) {
				await machines();
				return;
			}

			if (_pathParts.includes('/machines') && _pathParts.length === 5) {
				await machine(machineData);
				return;
			}

			if (_pathParts.includes('/genres') && _pathParts.length === 3) {
				await genresGroup();
				return;
			}

			if (_pathParts.includes('/genres') && _pathParts.length === 4) {
				await genreMachines();
				return;
			}

			const routeFunction = {
				'/genres': genres,
				'/saved': saved,
				'/reports/run': runReports,
				'/reports/view': viewReports,
				'/reports/sql': sqlReports,
				'/import': importFiles,
				'/export': exportFiles,
				'/tools': tools,
				'/settings': settings,
				'/bittorrent': bittorrent,
				'/about': about,
			}[_path];

			if (routeFunction !== undefined)
				await routeFunction();
		}

		//
		// Settings
		//
		const settings = async () => {

			const canvas = getCanvas();

			const data = await fetchJson('/api/settings');

			let html = '<hr />';

			Object.keys(data.available_options).forEach((key) => {
				html += `<h2>${key}</h2><p>${data.option_descriptions[key]}</p>`
				html += `<select id="settings_${key}" onchange="runCommand('.set ${key} ' + this.value)">`;

				data.available_options[key].forEach((option) => {
					html += `<option value="${option}">${option}</option>`;
				});

				html += '</select>';
				html += '<hr />';
			});


			let div = document.createElement('div');
			div.innerHTML = html;
			canvas.appendChild(div);

			Object.keys(data.available_options).forEach((key) => {
				document.getElementById(`settings_${key}`).value = data.options[key];
			});
		}

		//
		// BitTorrent
		//
		const bittorrent = async () => {

			const canvas = getCanvas();

			const refreshLink = '<p><a href="javascript:window.location.href=window.location.href">Refresh this page to see changes</a></p>';

			let div;
			let table;
			let columnDefs;

			if (_info.bit_torrent_enabled !== true) {

				div = document.createElement('div');
				div.innerHTML = '<h2>BitTorrent Currently Disabled</h2>' +
					'<p>Click button to enable immediately. You will have to Allow in Windows Firewall when the dialog apears.</p>' +
					'<button type="submit" onclick="runCommand(\'.bt\'); return false;">Enable BitTorrent</button>' +
					refreshLink;
				canvas.appendChild(div);
				return;
			}


			div = document.createElement('div');
			div.innerHTML = 'Connecting to DOME-BT ...';
			canvas.appendChild(div);

			let btInfo;
			try {
				btInfo = await fetchJson('/api/info', _info.bit_torrent_url);
				div.innerHTML = '';
			}
			catch (e) {
				div.innerHTML = `<h2>Error connecting to DOME-BT</h2><p>Ensure the DOME-BT process is running you can use the command ".bt" or click the button.</p><p>Error: ${e.message}</p>` +
					'<button type="submit" onclick="runCommand(\'.bt\'); return false;">Start BitTorrent</button>' +
					refreshLink;
				return;
			}

			// BitTorrent Client Information

			div = document.createElement('div');
			div.style = 'width:100%;';
			div.innerHTML = '<h2>BitTorrent Client Information</h2><table style="width:100%;">' +
				'<tr><th>Version</th><th>Start Time</th><th>Time Now</th><th>Running for</th></tr>' +
				`<tr><td>DOME-BT ${btInfo.version}</td><td>${btInfo.start_time}</td><td>${btInfo.time_now}</td><td>${btInfo.run_time_text}</td></tr>` +
				'</table>';
			canvas.appendChild(div);

			div = document.createElement('div');
			div.style = 'width:100%;';
			div.innerHTML = '<table style="width:100%;">' +
				'<tr><th>Open Connections</th><th>Download Rate</th><th>Upload Rate</th></tr>' +
				`<tr><td>${btInfo.open_connections}</td><td>${btInfo.total_download_rate_text}/s</td><td>${btInfo.total_upload_rate_text}/s</td></tr>` +
				'</table>';
			canvas.appendChild(div);

			div = document.createElement('div');
			div.style = 'width:100%;';
			div.innerHTML = '<table style="width:100%;">' +
				'<tr><th>Download Total</th><th>Upload Total</th></tr>' +
				`<tr><td>${btInfo.total_bytes_received_text}</td><td>${btInfo.total_bytes_sent_text}</td></tr>` +
				'</table>';
			canvas.appendChild(div);

			// BitTorrents

			div = document.createElement('div');
			div.style = 'width:100%;';
			div.innerHTML = '<hr /><h2>BitTorrents</h2>';
			canvas.appendChild(div);

			columnDefs = [
				{ heading: 'Name', columnName: 'name' },
				{ heading: 'State', columnName: 'state' },
				{ heading: 'File Count', columnName: 'file_count' },
				{ heading: 'Open Connections', columnName: 'open_connections' },
				{ heading: 'Peers Available', columnName: 'peers_available' },
				{ heading: 'Peers Leechs', columnName: 'peers_leechs' },
				{ heading: 'Peers Seeds', columnName: 'peers_seeds' },
				{ heading: 'Downloaded', columnName: 'bytes_received_text' },
				{ heading: 'Uploaded', columnName: 'bytes_sent_text' },
			];

			table = document.createElement('table');
			table.style = 'width:100%;';

			buildTable(columnDefs, btInfo.torrents, table, (columnDef, result, resultIndex, row, cell) => {

				const value = result[columnDef.columnName];

				if (value === undefined)
					return;

				switch (columnDef.columnName) {

					case 'state':
						cell.innerHTML = `<a href="${_info.bit_torrent_url}/api/files?hash=${result.hash}&priority=Highest" target="_blank">${value}</a>`;
						break;

					case 'file_count':
						cell.innerHTML = `<a href="${_info.bit_torrent_url}/api/files?hash=${result.hash}" target="_blank">${value}</a>`;
						break;

					default:
						cell.innerHTML = value;
						break;
				}
			});
			canvas.appendChild(table);

			// Port Mappings

			div = document.createElement('div');
			div.innerHTML = '<hr /><h2>Port Mappings</h2>';
			canvas.appendChild(div);

			columnDefs = [
				{ heading: 'Name', columnName: 'name' },
				{ heading: 'Mappings', columnName: 'mappings' },
			];

			table = document.createElement('table');

			buildTable(columnDefs, btInfo.port_mappings, table, (columnDef, result, resultIndex, row, cell) => {

				const value = result[columnDef.columnName];

				if (value === undefined)
					return;

				switch (columnDef.columnName) {

					case 'mappings':
						cell.innerHTML = value.map(item => `${item.protocol}:${item.public_port}`).join(', ');
						break;

					default:
						cell.innerHTML = value;
						break;
				}
			});
			canvas.appendChild(table);

			// BitTorrent Client Details

			div = document.createElement('div');
			div.innerHTML = '<hr /><h2>BitTorrent Client Details</h2>';
			canvas.appendChild(div);

			const infoData = [];

			Object.keys(btInfo).forEach((key) => {

				if (Array.isArray(btInfo[key]) === true)
					return;

				infoData.push({ key: key, value: btInfo[key] });
			});

			table = document.createElement('table');

			columnDefs = [
				{ heading: 'Key', columnName: 'key' },
				{ heading: 'Value', columnName: 'value' },
			];

			buildTable(columnDefs, infoData, table, (columnDef, result, resultIndex, row, cell) => {

				const value = result[columnDef.columnName];

				if (value === undefined)
					return;

				cell.innerHTML = value;
			});

			canvas.appendChild(table);

			// Magnet Links

			div = document.createElement('div');
			div.innerHTML = '<hr /><h2>Magnet Links</h2>';
			canvas.appendChild(div);

			columnDefs = [
				{ heading: 'Asset Type', columnName: 'type' },
				{ heading: 'Name / Link', columnName: 'name' },
				{ heading: 'Version', columnName: 'version' },
				{ heading: 'Available', columnName: 'torrent_available' },
			];

			table = document.createElement('table');

			buildTable(columnDefs, btInfo.magnets, table, (columnDef, result, resultIndex, row, cell) => {

				const value = result[columnDef.columnName];

				if (value === undefined)
					return;

				switch (columnDef.columnName) {

					case 'name':
						cell.innerHTML = `<a href="${result.magnet_link}" target="_blank">${value}</a>`;
						break;
					default:
						cell.innerHTML = value;
						break;
				}
			});
			canvas.appendChild(table);

			// Restart & Stop

			div = document.createElement('div');
			div.innerHTML = '<hr /><h2>Restart & Stop BitTorrent</h2>' +
				'<p>Cleanly shutdown or restart BitTorrent.</p>' +
				'<button type="submit" onclick="runCommand(\'.btr\'); return false;">Restart BitTorrent</button>' +
				'<button type="submit" onclick="runCommand(\'.bts\'); return false;">Stop BitTorrent</button>' +
				refreshLink;
			canvas.appendChild(div);

			// Disable

			div = document.createElement('div');
			div.innerHTML = '<hr /><h2>Disable BitTorrent</h2>' +
				'<p>Click button to disable & remove BitTorrent.</p>' +
				'<p>If you want to use archive.org for downloading assets use the command ".creds" to enter your credentials if you have not already.</p>' +
				'<button type="submit" onclick="runCommand(\'.btx\'); return false;">Disable BitTorrent</button>' +
				refreshLink;
			canvas.appendChild(div);
		}

		//
		// About
		//
		const about = async () => {

			const canvas = getCanvas();

			let html = '';

			// Links
			html += `<h2>Further Info Links</h2><table><tr><th>Description</th><th>URL</th></tr>`;

			html += `<tr><td>What's New in the latest MAME release</td><td><a href="${_baseUrl}/api/what" target="_blank">${_baseUrl}/api/what</a></td></tr>`;
			html += `<tr><td>MAME Official Docs</td><td><a href="https://docs.mamedev.org/" target="_blank">https://docs.mamedev.org/</a></td></tr>`;
			html += `<tr><td>MAME-AO README</td><td><a href="https://github.com/sam-ludlow/mame-ao" target="_blank">https://github.com/sam-ludlow/mame-ao</a></td></tr>`;
			html += `<tr><td>Spludlow Data Web</td><td><a href="https://data.spludlow.co.uk/" target="_blank">https://data.spludlow.co.uk/</a></td></tr>`;
			html += `<tr><td>MAME-AO API Information</td><td><a href="${_baseUrl}/api/info" target="_blank">${_baseUrl}/api/info</a></td></tr>`;

			if (_info.bit_torrent_enabled === true)
				html += `<tr><td>DOME-BT API Information</td><td><a href="${_info.bit_torrent_url}/api/info" target="_blank">${_info.bit_torrent_url}/api/info</a></td></tr>`;

			if (_info.linking_enabled !== true)
				html += '<tr><td>WARNING Symbolic Links are not enabled, you can save disk space, view instructions on enabling.</td><td><a href="https://github.com/sam-ludlow/mame-ao?tab=readme-ov-file#symbolic-links---save-disk-space" target="_blank">https://github.com/sam-ludlow/mame-ao?tab=readme-ov-file#symbolic-links---save-disk-space</a></td></tr>';

			html += '</table><hr />';

			// Cores
			html += `<h2>Emulator Cores</h2><table><tr><th>Name</th><th>Status</th></tr><p>HBMAME only works with BitTorrent.</p>`;

			_info.cores.forEach((core_name) => {
				let coreStatus = core_name === _info.core_name ? `Currently running version: ${_info.core_version}` : `<button type="submit" onclick="runCommand('.core ${core_name}'); return false;">Enable</button>`;
				html += `<tr><td>${core_name.toUpperCase()}</td><td>${coreStatus}</td></tr>`;
			});

			html += '</table>';
			html += '<p><a href="javascript:window.location.href=window.location.href">Refresh this page to see changes</a></p>';

			html += '<hr /><h2>System Information</h2>';

			let div = document.createElement('div');
			div.innerHTML = html;
			canvas.appendChild(div);

			// System Information
			const infoData = [];

			Object.keys(_info).forEach((key) => {

				if (key === 'latest' || key === 'sources' || key === 'items' || key === 'repos')
					return;

				infoData.push({ key: key, value: _info[key] });
			});

			let table = document.createElement('table');

			let columnDefs = [
				{ heading: 'Key', columnName: 'key' },
				{ heading: 'Value', columnName: 'value' },
			];

			buildTable(columnDefs, infoData, table, (columnDef, result, resultIndex, row, cell) => {

				const value = result[columnDef.columnName];

				if (value === undefined)
					return;

				cell.innerHTML = value;
			});

			canvas.appendChild(table);

			// Repos

			div = document.createElement('div');
			div.innerHTML = '<hr /><h2>GitHub.com Repos</h2>';
			canvas.appendChild(div);

			columnDefs = [
				{ heading: 'Key', columnName: 'key' },
				{ heading: 'User Name', columnName: 'user_name' },
				{ heading: 'Repo Name', columnName: 'repo_name' },
				{ heading: 'Latest (tag_name)', columnName: 'tag_name' },
				{ heading: 'Published', columnName: 'published_at' },
				{ heading: 'Details URL', columnName: 'url_details' },
				{ heading: 'Metadata URL', columnName: 'url_api' },
			];

			table = document.createElement('table');

			buildTable(columnDefs, _info.repos, table, (columnDef, result, resultIndex, row, cell) => {

				const value = result[columnDef.columnName];

				if (value === undefined)
					return;

				cell.innerHTML = value;

				switch (columnDef.columnName) {

					case 'url_details':
					case 'url_api':
						cell.innerHTML = `<a href="${value}" target="_blank">${value}</a>`;
						break;
				}
			});

			canvas.appendChild(table);

			// Items

			div = document.createElement('div');
			div.innerHTML = '<hr /><h2>Archive.org Items</h2>';
			canvas.appendChild(div);

			columnDefs = [
				{ heading: 'Key', columnName: 'key' },
				{ heading: 'Type', columnName: 'type' },
				{ heading: 'Tag', columnName: 'tag' },
				{ heading: 'Status', columnName: 'status' },
				{ heading: 'Title', columnName: 'title' },
				{ heading: 'File Count', columnName: 'file_count' },
				{ heading: 'Last Updated', columnName: 'item_last_updated' },
				{ heading: 'Details URL', columnName: 'url_details' },
				{ heading: 'Metadata URL', columnName: 'url_metadata' },
				{ heading: 'Download URL', columnName: 'url_download' },
				{ heading: 'Sub Directory', columnName: 'sub_directory' },
			];

			table = document.createElement('table');

			buildTable(columnDefs, _info.items, table, (columnDef, result, resultIndex, row, cell) => {

				const value = result[columnDef.columnName];

				if (value === undefined)
					return;

				cell.innerHTML = value;

				switch (columnDef.columnName) {

					case 'url_details':
					case 'url_metadata':
					case 'url_download':
						cell.innerHTML = `<a href="${value}" target="_blank">${value}</a>`;
						break;
				}
			});

			canvas.appendChild(table);

			// End Points

			const data = await fetchJson('/api/end_points');

			div = document.createElement('div');
			div.innerHTML = '<hr /><h2>Endpoint Locations</h2>';
			canvas.appendChild(div);

			columnDefs = [
				{ heading: 'Name', columnName: 'name' },
				{ heading: 'Location', columnName: 'location' },
			];

			table = document.createElement('table');

			buildTable(columnDefs, data.results, table, (columnDef, result, resultIndex, row, cell) => {

				const value = result[columnDef.columnName];

				cell.innerHTML = value;

				switch (columnDef.columnName) {

					case 'location':
						cell.innerHTML = `<a href="${value}" target="_blank">${value}</a>`;
						break;
				}
			});

			canvas.appendChild(table);
		}

		//
		// Tools
		//
		const tools = async () => {
			const canvas = getCanvas();

			let html;
			let div;

			// Snaps & SVG
			html = '';
			html += '<h2>Snaps Collection & Convert PNG into SVG</h2>';
			html += '<p>Copy and paste the directory path or filename here.</p>';
			html += '<input id="directory" type="text" value="" style="width:480px;" />';
			html += '<p>Collect and Move Snaps (F12 pictures) to directory.</p>';
			html += '<button type="submit" onclick="runCommand(\'.snap \' + directory.value); return false;">Collect Snaps</button>';
			html += '<p>Convert bitmaps to SVG, single filename or directory for all files</p>';
			html += '<button type="submit" onclick="runCommand(\'.svg \' + directory.value); return false;">Convert to SVG</button>';

			div = document.createElement('div');
			div.innerHTML = html;
			canvas.appendChild(div);

			document.getElementById('directory').focus();

			// MS Access
			html = '<hr />';
			html += '<h2>Create MS Access databases</h2>';
			html += '<p>Requires <a href="https://github.com/sam-ludlow/access-linker/releases" target="_blank">access-linker.exe</a> in the MAME-AO directory, and other dependencies (ODBC & OLE DB drivers) see the <a href="https://github.com/sam-ludlow/access-linker" target="_blank">access-linker README</a>.</p>';
			html += '<p>MS Access databases from complete MAME XML. Usfull for looking at the MAME data.</p>';
			html += '<button type="submit" onclick="runCommand(\'.accdbxml\'); return false;">Create from MAME XML</button>';
			html += '<p>MS Access databases linked to MAME-AO SQLite. Usfull for debugging MAME-AO.</p>';
			html += '<button type="submit" onclick="runCommand(\'.accdb\'); return false;">Link to MAME-AO SQLite</button>';

			div = document.createElement('div');
			div.innerHTML = html;
			canvas.appendChild(div);

			// Test
			const dataProfiles = await fetchJson('/api/profiles');

			html = '<hr />';
			html += '<h2>Run MAME-AO asset place tests</h2>';
			html += '<p>Randomly place assets and test with MAME verifyroms, Test will stop with a non zero exit code from MAME.</p>';
			html += '<p><select id="testProfile">' + dataProfiles.results.map((profile) => `<option value="${profile.key}">${profile.text}</option>`).join() + '</select></p>';
			html += '<p><select id="testCount">' + [1, 8, 16, 32, 64, 128, 256, 512, 1024, 4096, 0].map((count) => `<option value="${count}">${count}</option>`).join() + '</select></p>';
			html += '<button type="submit" onclick="runCommand(\'.test \' + testProfile.value + \' \' + testCount.value); return false;">Run Tests</button>';

			div = document.createElement('div');
			div.innerHTML = html;
			canvas.appendChild(div);

			// Store
			html = '<hr />';
			html += '<h2>Store Validation</h2>';
			html += '<p>WARNING: These can take a while if you have a lot of stuff.</p>';
			html += '<p>Validate the ROM Hash Store, each file will be SHA1 hashed and compared to the filename.</p>';
			html += `<button type="submit" onclick="runCommand(\'.valid rom\'); return false;">Validate ROM</button>`;
			html += '<p>Validate the DISK Hash Store, each file will have the SHA1 verified with chdman.exe and compared to the filename.</p>';
			html += '<button type="submit" onclick="runCommand(\'.valid disk\'); return false;">Validate DISK</button>';

			div = document.createElement('div');
			div.innerHTML = html;
			canvas.appendChild(div);
		}

		//
		// Import
		//
		const importFiles = async () => {

			const canvas = getCanvas();

			const softwarelistData = await fetchJson('/api/softwarelists');

			let html = '';
			html += '<h2>Import from Directory</h2>'
			html += '<p>Copy and paste the directory path to import from here. Anything required in the current core will be imported to the store.</p>';
			html += '<p><input id="importDirectory" type="text" value="" style="width:480px;" /></p>';
			html += '<button type="submit" onclick="runCommand(\'.import \' + importDirectory.value); return false;">Import from Directory</button>';

			html += `<hr /><h2>Fetch Complete Software List</h2>`;
			html += '<p>Fetch a comlpete software list and place ready to use from within MAME.</p>';
			html += '<p><select id="softwareListPlace">' + softwarelistData.results.map((list) => `<option value="${list.name}">${list.description}</option>`).join() + '</select></p>';
			html += '<button type="submit" onclick="runCommand(\'.software \' + softwareListPlace.value); return false;">Fetch & Place</button>';

			html += `<hr /><h2>Fetch Everything</h2>`;
			html += '<p>If you are maintaining full sets use fetch to top-up the hash store. Nothing will be placed only stored.</p>';
			html += '<p><select id="fetchType"><option value="MR">Machine ROM</option><option value="MD">Machine DISK</option><option value="SR">Software ROM</option><option value="SD">Software DISK</option><option value="*">Everything</option></select></p>';
			html += '<button type="submit" onclick="runCommand(\'.fetch \' + fetchType.value); return false;">Fetch All</button>';

			const div = document.createElement('div');
			div.innerHTML = html;
			canvas.appendChild(div);

			document.getElementById('importDirectory').focus();
		}

		//
		// Export
		//
		const exportFiles = async () => {

			const canvas = getCanvas();

			const softwarelistData = await fetchJson('/api/softwarelists');

			let html = '';

			html += '<h2>Target Directory</h2>';
			html += '<p>Copy and paste the directory path to here.</p>';
			html += '<input id="targetDirectory" type="text" value="" style="width:480px;" />';

			html += '<hr /><h2>Standard MAME format (split-set)</h2>';
			html += '<p>Export everything in current core thats in the store. Machine ROMs will be in split-set format (separate parent ZIP & child diff ZIPs).</p>';
			html += '<p><select id="exportType"><option value="*">Everything</option><option value="MR">Machine ROM</option><option value="MD">Machine DISK</option><option value="SR">Software ROM</option><option value="SD">Software DISK</option></select></p>';
			html += '<button type="submit" onclick="runCommand(\'.export \' + exportType.value + \' \' + targetDirectory.value); return false;">Start</button>';

			html += '<hr /><h2>Fetch complete software lists with friendly names</h2>';
			html += '<p>Complete software list will be downloaded and exported to directory with friendly filenames.</p>';
			html += '<p><select id="selectList">' + softwarelistData.results.map((list) => `<option value="${list.name}">${list.description}</option>`).join() + '</select></p>';
			html += '<p><input type="checkbox" id="inputUseDirs">Use directories for each software</input></p>';
			html += '<button type="submit" onclick="runCommand(\'.softname\' + (inputUseDirs.checked ? \'d\' : \'\') + \' \' + selectList.value + \' \' + targetDirectory.value); return false;">Start</button>';

			const div = document.createElement('div');
			div.innerHTML = html;
			canvas.appendChild(div);
			
			document.getElementById('targetDirectory').focus();
		}

		//
		// Saved state
		//
		const saved = async () => {

			const canvas = getCanvas();

			const data = await fetchJson('/api/list');

			const columnDefs = [
				{ heading: 'MAME Version', columnName: 'version' },
				{ heading: 'MAME Binary Time', columnName: 'binary_time' },
				{ heading: 'Save Name', columnName: 'sta_name' },
				{ heading: 'Save Time', columnName: 'sta_time' },
				{ heading: 'Machine Name', columnName: 'sta_machine' },
				{ heading: 'Machine Description', columnName: 'sta_description' },
			];

			const table = document.createElement('table');
			table.style = 'margin-left: auto; margin-right: auto;';

			buildTable(columnDefs, data.results, table, (columnDef, result, resultIndex, row, cell) => {

				switch (columnDef.columnName) {

					case 'version':
						cell.innerHTML = `<a onclick="runCommand('.${result.version}')" href="javascript:void(0);">${result.version}</a>`;
						break;

					case 'sta_machine':
						if (result.sta_machine !== undefined)
							cell.innerHTML = `<a onclick="runCommand('.${result.version} ${result.sta_machine}')" href="javascript:void(0);">${result.sta_machine}</a>`;
						break;

					default:
						if (result[columnDef.columnName] !== undefined)
							cell.innerHTML = result[columnDef.columnName];
						break;
				}
			});

			canvas.appendChild(table);
		}

		//
		// Run Reports
		//
		const runReports = async () => {

			const canvas = getCanvas();

			let html = '';

			html += 'Click report code to run report. It will pop up in default browser when finished.';

			const report_groups = await fetchJson('/api/report_groups');
			const report_types = await fetchJson('/api/report_types');

			report_groups.results.forEach((report_group, index) => {

				if (index > 0)
					html += '<hr />';

				html += `<h2>${report_group.text} (${report_group.key})</h2>`;
				html += `<p>${report_group.description}</p>`;

				html += '<table>';
				html += '<tr><th>key</th><th>code</th><th>text</th><th>description</th></tr>';

				report_types.results.filter(report_type => report_type.group === report_group.key).forEach(report_type => {

					html += `<tr><td>${report_type.key}</td><td><a href="javascript:void(0);" onclick="runCommand('.report ${report_type.code}')" >${report_type.code}</a></td><td>${report_type.text}</td><td>${report_type.description}</td></tr>`;
				});

				html += '</table>';
			});

			const div = document.createElement('div');
			div.innerHTML = html;
			canvas.appendChild(div);
		}

		//
		// View Reports
		//
		const viewReports = async () => {

			const canvas = getCanvas();

			const data = await fetchJson('/api/reports');

			const table = document.createElement('table');
			table.style = 'margin-left: auto; margin-right: auto;';

			const headRow = document.createElement('tr');
			let cell;

			cell = document.createElement('th');
			cell.innerHTML = 'Report Date';
			headRow.appendChild(cell);

			cell = document.createElement('th');
			cell.innerHTML = 'Report Description';
			headRow.appendChild(cell);

			table.appendChild(headRow);

			data.results.forEach((report) => {

				const tableRow = document.createElement('tr');

				let cell;

				cell = document.createElement('td');
				cell.innerHTML = `<a href="${_baseUrl}/api/report?name=${encodeURIComponent(report.name)}" target="_blank">${report.date.replace('T', ' ')}</a>`;
				tableRow.appendChild(cell);

				cell = document.createElement('td');
				cell.innerHTML = `${report.description}`;
				tableRow.appendChild(cell);

				table.appendChild(tableRow);
			});

			canvas.appendChild(table);
		}

		//
		// SQL Query
		//
		const sqlReports = async () => {

			const canvas = getCanvas();

			let html = `<select id="commandDatabase">`;
			['machine', 'software'].forEach((database) => {
				html += `<option value="${database}">${database}</option>`;
			});
			html += '</select>';
			html += '<button id="commandButton" type="submit" onclick="sqlReportsExecute(commandDatabase.value, commandText.value); return false;">Query</button>';
			html += '<input type="checkbox" id="commandSaveReport">Save Report</input>';
			html += '<hr /><textarea id="commandText" rows="12" style="width: 100%; box-sizing: border-box;"></textarea>';
			html += '<hr /><div id="commandResult"></div>';

			const div = document.createElement('div');
			div.innerHTML = html;
			canvas.appendChild(div);

			const textarea = document.getElementById('commandText');
			textarea.focus();
		}
		const sqlReportsExecute = async (database, commandText) => {

			const button = document.getElementById('commandButton');
			button.disabled = true;
			button.innerHTML = 'Running Command...';

			const checkboxSaveReport = document.getElementById('commandSaveReport');

			const response = await fetch(`${_baseUrl}/api/sql_query?database=${database}&save=${checkboxSaveReport.checked}`, {
				method: 'POST',
				body: commandText,
			});

			const result = await response.json();

			const resultDiv = document.getElementById("commandResult");
			resultDiv.innerHTML = '';

			if (result.results !== undefined) {

				if (checkboxSaveReport.checked === false) {

					const table = document.createElement('table');
					resultDiv.appendChild(table);

					const headRow = document.createElement('tr');
					result.column_names.forEach((columnName) => {
						const th = document.createElement('th');
						th.innerHTML = columnName;
						headRow.appendChild(th);
					});
					table.appendChild(headRow);

					result.results.forEach(item => {

						const row = document.createElement('tr');
						result.column_names.forEach((columnName) => {
							const td = document.createElement('td');
							td.innerHTML = item[columnName] !== undefined ? htmlEncode(`${item[columnName]}`) : '';
							row.appendChild(td);
						});
						table.appendChild(row);

					});
				} else {
					resultDiv.innerHTML = `Report Saved, rows: ${result.results.length}`;
				}

			} else {
				resultDiv.innerHTML = result.message;
			}

			button.disabled = false;
			button.innerHTML = 'Query';
		}

		//
		// Genres
		//
		const genres = async () => {

			const canvas = getCanvas();

			const genre_groups = await fetchJson('/api/genre_groups');

			const columnDefs = [
				{ heading: 'Genre Group', columnName: 'group_name' },
				{ heading: 'Status Good', columnName: 'good' },
				{ heading: 'Status Imperfect', columnName: 'imperfect' },
				{ heading: 'Status Preliminary', columnName: 'preliminary' },
			];

			const table = document.createElement('table');
			table.style = 'margin-left: auto; margin-right: auto;';

			buildTable(columnDefs, genre_groups.results, table, (columnDef, result, resultIndex, row, cell) => {

				let html;

				const value = result[columnDef.columnName];

				switch (columnDef.columnName) {

					case 'group_name':
						html = `<a href="${_baseUrl}/genres/${encodeURIComponent(value)}">${value}</a>`;
						break;

					default:
						html = value;
						break;
				}

				if (html === 0)
					html = '';

				cell.innerHTML = html;

			});

			canvas.appendChild(table);
		}

		//
		// Genres Group
		//
		const genresGroup = async () => {

			const canvas = getCanvas();

			let parts = _pathParts[2].split('/');
			const group_name = decodeURIComponent(parts[parts.length - 1]);

			const genres = await fetchJson(`/api/genres?group_name=${encodeURIComponent(group_name)}`);

			const columnDefs = [
				{ heading: 'Genre', columnName: 'genre_name' },
				{ heading: 'Status Good', columnName: 'good' },
				{ heading: 'Status Imperfect', columnName: 'imperfect' },
				{ heading: 'Status Preliminary', columnName: 'preliminary' },
			];

			const table = document.createElement('table');
			table.style = 'margin-left: auto; margin-right: auto;';

			buildTable(columnDefs, genres.results, table, (columnDef, result, resultIndex, row, cell) => {

				let html;

				const value = result[columnDef.columnName];

				switch (columnDef.columnName) {

					case 'genre_name':
						html = `<a href="${_baseUrl}/genres/${encodeURIComponent(group_name)}/${encodeURIComponent(value)}">${value}</a>`;
						break;

					default:
						html = value;
						break;
				}

				if (html === 0)
					html = '';

				cell.innerHTML = html;

			});

			canvas.appendChild(table);
		}

		//
		// Machines in Genre
		//
		const genreMachines = async () => {

			const canvas = getCanvas();

			let parts = _pathParts[3].split('/');
			const genre_name = decodeURIComponent(parts[parts.length - 1]);

			const genres = await fetchJson(`/api/genres?genre_name=${encodeURIComponent(genre_name)}`);
			const genre_id = genres.results[0].genre_id;

			let profileKey = `genre-${genre_id}`;

			const machinesData = await (await fetch(`${_baseUrl}/api/machines?profile=${profileKey}&offset=${_parameters.offset}&search=${_parameters.search}`)).json();

			profileKey = 'everything';

			showMachines(canvas, machinesData, profileKey);
		}

		//
		// Machines in Data Profile
		//
		const machines = async () => {

			const canvas = getCanvas();

			let parts = _pathParts[2].split('/');
			const profileKey = parts[parts.length - 1];

			const machinesData = await fetchJson(`/api/machines?profile=${profileKey}&offset=${_parameters.offset}&search=${_parameters.search}&sortColumn=${_parameters.sortColumn || ''}&sortDirection=${_parameters.sortDirection || ''}`);

			showMachines(canvas, machinesData, profileKey);
		}

		//
		// Show Machines
		//
		const showMachines = (canvas, machinesData, profileKey) => {

			const navHtml = navigateHtml(machinesData);

			let html = '';

			html += `<input id="inputText" type="text" value="${_parameters.search}" style="width:480px;" />`;
			html += '<button type="submit" onclick="searchButton(); return false;">Search</button>';
			html += '&nbsp;&nbsp;';
			html += 'Sort by: <select id="sortSelect" onchange="changeSortMachines()">';
			html += '<option value="description">Name</option>';
			html += '<option value="year">Year</option>';
			html += '<option value="manufacturer">Manufacturer</option>';
			html += '<option value="name">ROM Name</option>';
			html += '</select>';
			html += '&nbsp;';
			html += '<select id="sortDirection" onchange="changeSortMachines()">';
			html += '<option value="asc">Ascending</option>';
			html += '<option value="desc">Descending</option>';
			html += '</select>';
			html += '<hr />';
			html += `<nav>${navHtml}</nav>`;
			html += '<div id="results"></div>';
			html += `<nav>${navHtml}</nav>`;

			const div = document.createElement('div');
			div.innerHTML = html;
			canvas.appendChild(div);

			const results = document.getElementById('results');

			if (machinesData.results.length === 0) {
				results.insertAdjacentHTML('beforeend', `<p><b>No results - try looking in <a href="/machines/everything?search=${_parameters.search}">Everything</a></b></p>`);
			} else {
				// Create grid container
				const grid = document.createElement('div');
				grid.className = 'game-grid';

				machinesData.results.forEach((result, index) => {
					const card = document.createElement('div');
					card.className = 'game-card';
					if (result.status) {
						card.classList.add(`game-card-status-${result.status.toLowerCase()}`);
					}

					// Determine click action
					let clickAction = '';
					if (result.ao_softwarelist_count > 0) {
						clickAction = `window.location.href='${_baseUrl}/machines/${profileKey}/${result.name}'`;
					} else {
						clickAction = `runCommand('${result.name}@${_info.core_name}')`;
					}

					card.innerHTML = `
						<div class="game-card-image" onclick="${clickAction}">
							<img src="${result.ao_image}" loading="lazy" alt="${result.description || result.name}" />
						</div>
						<div class="game-card-info">
							<div class="game-card-title" title="${result.description || result.name}">${result.description || result.name}</div>
							<div class="game-card-row"><span class="game-card-label">Name:</span><span class="game-card-value">${result.name}</span></div>
							${result.year ? `<div class="game-card-row"><span class="game-card-label">Year:</span><span class="game-card-value">${result.year}</span></div>` : ''}
							${result.manufacturer ? `<div class="game-card-row"><span class="game-card-label">Mfr:</span><span class="game-card-value" title="${result.manufacturer}">${result.manufacturer}</span></div>` : ''}
							${result.ao_rom_count > 0 ? `<div class="game-card-row"><span class="game-card-label">ROMs:</span><span class="game-card-value">${result.ao_rom_count}</span></div>` : ''}
							${result.ao_disk_count > 0 ? `<div class="game-card-row"><span class="game-card-label">Disks:</span><span class="game-card-value">${result.ao_disk_count}</span></div>` : ''}
							${result.ao_softwarelist_count > 0 ? `<div class="game-card-row"><span class="game-card-label">Lists:</span><span class="game-card-value">${result.ao_softwarelist_count}</span></div>` : ''}
							${result.cloneof ? `<div class="game-card-row"><span class="game-card-label">Clone:</span><span class="game-card-value">${result.cloneof}</span></div>` : ''}
							${result.romof ? `<div class="game-card-row"><span class="game-card-label">ROM:</span><span class="game-card-value">${result.romof}</span></div>` : ''}
							${result.status ? `<div class="game-card-row"><span class="game-card-label">Status:</span><span class="game-card-value">${result.status}</span></div>` : ''}
							${result.emulation ? `<div class="game-card-row"><span class="game-card-label">Emu:</span><span class="game-card-value">${result.emulation}</span></div>` : ''}
							<div class="game-card-row">
								<span class="game-card-label">Fav:</span>
								<input type="checkbox" id="fav_${result.name}" onclick="changeFavoriteMachine(this.id, ${index}); event.stopPropagation();" ${result.favorite ? 'checked' : ''} />
							</div>
						</div>
					`;

					grid.appendChild(card);
				});

				results.appendChild(grid);
			}

			const inputText = document.getElementById('inputText');
			inputText.focus();
			
			// Set the selected sort values
			document.getElementById('sortSelect').value = _parameters.sortColumn || 'name';
			document.getElementById('sortDirection').value = _parameters.sortDirection || 'asc';
		}
		
		const changeSortMachines = () => {
			const sortColumn = document.getElementById('sortSelect').value;
			const sortDirection = document.getElementById('sortDirection').value;
			
			const params = new URLSearchParams();
			params.set('offset', 0); // Reset to first page when sorting
			params.set('search', _parameters.search);
			params.set('sortColumn', sortColumn);
			params.set('sortDirection', sortDirection);
			
			window.location.href = `${_path}?${params.toString()}`;
		}
		
		const changeFavoriteMachine = async (checkBoxId, resultIndex) => {
			const checkBox = document.getElementById(checkBoxId);

			const name = checkBoxId.substring(4);

			const command = checkBox.checked ? ".favm" : ".favmx";

			await runCommand(`${command} ${name}`);

			const row = checkBox.parentElement.parentElement;

			const cell = row.cells[1];
			if (checkBox.checked === false)
				cell.className = '';
			else
				cell.className = (resultIndex % 2) ? 'fav-odd' : 'fav-even';
		}

		//
		// Machine (Show software)
		//
		const machine = async (machineData) => {

			const canvas = getCanvas();

			let parts = _pathParts[4].split('/');
			const softwarelist = parts[parts.length - 1];

			const softwareData = await fetchJson(`/api/software?softwarelist=${softwarelist}&offset=${_parameters.offset}&search=${_parameters.search}&favorites_machine=${machineData.name}&sortColumn=${_parameters.sortColumn || ''}&sortDirection=${_parameters.sortDirection || ''}`);

			const navHtml = navigateHtml(softwareData);

			let html = '';

			html += `<input id="inputText" type="text" value="${_parameters.search}" style="width:480px;" />`;
			html += '<button type="submit" onclick="searchButton(); return false;">Search</button>';
			html += '<hr />';
			html += `<nav>${navHtml}</nav>`;
			html += '<div id="results"></div>';
			html += `<nav>${navHtml}</nav>`;

			const div = document.createElement('div');
			div.innerHTML = html;
			canvas.appendChild(div);

			const results = document.getElementById('results');

			if (softwareData.results.length === 0) {
				results.insertAdjacentHTML('beforeend', `<p><b>No results</b></p>`);
			} else {
				// Create grid container
				const grid = document.createElement('div');
				grid.className = 'game-grid';

				softwareData.results.forEach((result, index) => {
					const card = document.createElement('div');
					card.className = 'game-card';

					const clickAction = `runCommand('${machineData.name}@${_info.core_name} ${result.name}@${result.softwarelist_name}')`;

					card.innerHTML = `
						<div class="game-card-image" onclick="${clickAction}">
							<img src="${result.ao_image}" loading="lazy" alt="${result.description || result.name}" />
						</div>
						<div class="game-card-info">
							<div class="game-card-title" title="${result.description || result.name}">${result.description || result.name}</div>
							<div class="game-card-row"><span class="game-card-label">Name:</span><span class="game-card-value">${result.name}</span></div>
							${result.year ? `<div class="game-card-row"><span class="game-card-label">Year:</span><span class="game-card-value">${result.year}</span></div>` : ''}
							${result.publisher ? `<div class="game-card-row"><span class="game-card-label">Pub:</span><span class="game-card-value" title="${result.publisher}">${result.publisher}</span></div>` : ''}
							${result.cloneof ? `<div class="game-card-row"><span class="game-card-label">Clone:</span><span class="game-card-value">${result.cloneof}</span></div>` : ''}
							${result.supported ? `<div class="game-card-row"><span class="game-card-label">Support:</span><span class="game-card-value">${result.supported}</span></div>` : ''}
							${_path.endsWith('/@fav') && result.softwarelist_name ? `<div class="game-card-row"><span class="game-card-label">List:</span><span class="game-card-value">${result.softwarelist_name}</span></div>` : ''}
							<div class="game-card-row">
								<span class="game-card-label">Fav:</span>
								<input type="checkbox" id="fav_${result.name}" onclick="changeFavoriteSoftware(this.id, '${machineData.name}', '${result.softwarelist_name}', ${index}); event.stopPropagation();" ${result.favorite ? 'checked' : ''} />
							</div>
						</div>
					`;

					grid.appendChild(card);
				});

				results.appendChild(grid);
			}

			const inputText = document.getElementById('inputText');
			inputText.focus();
		}
		const changeFavoriteSoftware = async (checkBoxId, machineName, listName, resultIndex) => {
			const checkBox = document.getElementById(checkBoxId);

			const softwareName = checkBoxId.substring(4);

			const command = checkBox.checked ? ".favs" : ".favsx";

			await runCommand(`${command} ${machineName} ${listName} ${softwareName}`);

			const row = checkBox.parentElement.parentElement;

			const cell = row.cells[1];
			if (checkBox.checked === false)
				cell.className = '';
			else
				cell.className = (resultIndex % 2) ? 'fav-odd' : 'fav-even';
		}

		const searchButton = async () => {

			const inputText = document.getElementById('inputText');

			document.location = `${_path}?search=${encodeURIComponent(inputText.value)}`;

		}

		const navigateHtml = (data) => {

			const limit = 100;

			const totalPages = Math.ceil(data.total / data.limit);
			const currentPage = (data.offset / data.limit) + 1;

			// Build URL with all current parameters
			const buildNavUrl = (offset) => {
				const params = new URLSearchParams();
				params.set('offset', offset);
				params.set('search', _parameters.search);
				if (_parameters.sortColumn) {
					params.set('sortColumn', _parameters.sortColumn);
				}
				if (_parameters.sortDirection) {
					params.set('sortDirection', _parameters.sortDirection);
				}
				return `${_path}?${params.toString()}`;
			};

			const firstPage = buildNavUrl(0);
			const lastPage = buildNavUrl((totalPages - 1) * limit);
			const prevPage = buildNavUrl(Math.max(0, _parameters.offset - limit));
			const nextPage = buildNavUrl(Math.min((totalPages - 1) * limit, _parameters.offset + limit));

			const buttonStyle = 'display:inline-block;min-width:40px;text-align:center;padding:6px 10px;border:2px solid #ccc;border-radius:8px;text-decoration:none;color:#333;background-color:#f5f5f5;';
			const currentPageStyle = 'display:inline-block;min-width:60px;text-align:center;padding:6px 10px;border:2px solid #4a90e2;border-radius:8px;background-color:#4a90e2;color:white;font-weight:bold;';

			return `<div style="margin-top:15px;margin-bottom:15px;"><a href="${firstPage}" title="First page" style="${buttonStyle}">&lt;&lt;</a>` +
				'&nbsp;' +
				`<a href="${prevPage}" title="Previous page" style="${buttonStyle}">&lt;</a>` +
				'&nbsp;' +
				`<span style="${currentPageStyle}">${currentPage} / ${totalPages}</span>` +
				'&nbsp;' +
				`<a href="${nextPage}" title="Next page" style="${buttonStyle}">&gt;</a>` +
				'&nbsp;' +
				`<a href="${lastPage}" title="Last page" style="${buttonStyle}">&gt;&gt;</a>` +
				'&nbsp; &nbsp;' +
				`<span style="color:#666;">(total: ${data.total} - viewing: ${data.count})</span></div>`;
		}

		//
		// Code Tools
		//

		const sleep = ms => new Promise(r => setTimeout(r, ms));

		const fetchJson = async (url, base = _baseUrl) => (await fetch(`${base}${url}`)).json();

		const getCanvas = () => {
			const page = document.getElementById('canvas');
			page.innerHTML = '';
			return page;
		}

		const runCommand = async (line) => {

			const response = await fetch(`${_baseUrl}/api/command?line=${encodeURIComponent(line)}`);

			const result = await response.json();

			if (response.status !== 200)
				alert(result.message);
		}

		const buildTableHeader = (columnDefs, table, enableSorting = true) => {
			const headRow = document.createElement('tr');
			columnDefs.forEach((columnDef, index) => {
				const cell = document.createElement('th');
				
				// Check if this specific column is sortable (default to true if not specified)
				const isSortable = enableSorting && (columnDef.sortable !== false);
				
				if (isSortable) {
					cell.style.cursor = 'pointer';
					cell.style.userSelect = 'none';
					
					// Check if this column is currently sorted
					const isSorted = _parameters.sortColumn === columnDef.columnName;
					const direction = _parameters.sortDirection || '';
					
					let indicator = '⇅';
					if (isSorted) {
						indicator = direction === 'asc' ? '▲' : '▼';
						cell.dataset.sortDirection = direction;
					}
					
					cell.innerHTML = `${columnDef.heading} <span class="sort-indicator">${indicator}</span>`;
					cell.onclick = () => sortTable(table, index, columnDef.columnName);
					cell.title = `Click to sort by ${columnDef.heading}`;
				} else {
					cell.innerHTML = columnDef.heading;
				}
				
				headRow.appendChild(cell);
			});
			table.appendChild(headRow);
		}

		const buildTable = (columnDefs, results, table, cellFunction, enableSorting = true) => {

			buildTableHeader(columnDefs, table, enableSorting);

			results.forEach((result, resultIndex) => {

				const row = document.createElement('tr');
				row.dataset.originalIndex = resultIndex;

				columnDefs.forEach((columnDef) => {
					const cell = document.createElement('td');
					cell.dataset.rawValue = result[columnDef.columnName] ?? '';
					cellFunction(columnDef, result, resultIndex, row, cell);
					row.appendChild(cell);
				});

				table.appendChild(row);
			});
		}

		const sortTable = (table, columnIndex, columnName) => {
			// Determine current sort direction from URL parameters
			let currentDirection = _parameters.sortDirection || 'none';
			let currentColumn = _parameters.sortColumn || '';
			
			// If clicking a different column, default to ascending
			// If clicking the same column, toggle direction
			let newDirection = 'asc';
			if (currentColumn === columnName) {
				newDirection = currentDirection === 'asc' ? 'desc' : 'asc';
			}
			
			// Build new URL with sort parameters
			const params = new URLSearchParams();
			params.set('offset', _parameters.offset);
			params.set('search', _parameters.search);
			params.set('sortColumn', columnName);
			params.set('sortDirection', newDirection);
			
			// Navigate to new URL with sort parameters
			window.location.href = `${_path}?${params.toString()}`;
		}

		const getRequestInfo = () => {

			_baseUrl = window.location.origin;

			_parameters = {};

			if (window.location.href.includes('?')) {

				const parts = window.location.href.split('?')[1].split('&');
				parts.forEach((part) => {
					const pair = part.split('=');
					_parameters[pair[0]] = decodeURIComponent(pair[1]);
				});
			}

			if (_parameters['offset'] === undefined)
				_parameters['offset'] = 0;
			else
				_parameters['offset'] = parseInt(_parameters['offset'], 10);

			if (_parameters['search'] === undefined)
				_parameters['search'] = '';

			// Set default sort to description ascending if not specified
			if (_parameters['sortColumn'] === undefined)
				_parameters['sortColumn'] = 'description';
			
			if (_parameters['sortDirection'] === undefined)
				_parameters['sortDirection'] = 'asc';

			_path = document.location.pathname;

			_pathParts = [];

			if (_path === '/') {
				_pathParts.push('/');
			} else {
				_path.split('/').forEach((part) => {
					if (part !== undefined) {
						let prev = '';
						if (_pathParts.length > 1)
							prev = _pathParts[_pathParts.length - 1];

						_pathParts.push(prev + '/' + part);
					}
				});
			}
		}

		const htmlEncode = (html) => html.replace(/[&<>'"]/g,
			tag => ({
				'&': '&amp;',
				'<': '&lt;',
				'>': '&gt;',
				"'": '&#39;',
				'"': '&quot;'
			}[tag]));

		//
		// Menu
		//

		const displayMenu = () => {

			const versions = `AO V${_info.version} (${_info.core_name?.toUpperCase()} ${_info.core_version})`;

			_rootMenu[0].text = versions;
			_rootMenu[0].title = versions;

			displayMenuWalk(_rootMenu);

			if (_currentMenu && _currentMenu.menu && _currentMenu.menu[0].href)
				document.location = `${_baseUrl}${_currentMenu.menu[0].href}`;
		}

		const displayMenuWalk = (menu) => {

			const nav = document.getElementById('nav');
			const heading = document.getElementById('heading');

			const table = document.createElement('table');
			table.style = "width: 100%;";

			const row = document.createElement('tr');

			let found;

			menu.forEach((item) => {
				const cell = document.createElement('td');

				let itemClass = 'nav-off';

				if (_pathParts.includes(item.href)) {

					itemClass = 'nav-on';
					found = item;
					document.title = item.title;
					heading.innerHTML = item.title;
				}

				if (_path === item.href)
					_currentMenu = item;

				cell.className = itemClass;

				if (item.style)
					cell.style = item.style;

				cell.innerHTML = `<a href="${item.href}" title="${item.title}" class="${itemClass}">${item.text}</a>`;

				row.appendChild(cell);
			});

			table.appendChild(row);
			nav.appendChild(table);

			if (found && found.menu)
				displayMenuWalk(found.menu);
		}

		//
		// Load
		//

		window.onload = main;

	</script>

</head>
<body>

	<div>
		<a style="float:left;" href="/"><img src="https://mame.spludlow.co.uk/snap/mame-ao-logo.png" /></a>
		<h1 id="heading"></h1>
	</div>

	<nav id="nav">
	</nav>

	<hr />

	<div id="error"></div>

	<form>
		<div id="canvas">
			<p>Loading...</p>
		</div>
	</form>

	<hr />

</body>
</html>
